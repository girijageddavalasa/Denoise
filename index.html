<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Denoiser</title>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Font (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Custom Tailwind Config -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'brand-primary': {
                            '50': '#eff8ff',
                            '100': '#dbeeff',
                            '200': '#bde0ff',
                            '300': '#94cbff',
                            '400': '#64a9ff',
                            '500': '#3f83ff',
                            '600': '#1c5dff',
                            '700': '#1a50d1',
                            '800': '#1e43a6',
                            '900': '#1e3a8a',
                            '950': '#172554'
                        }
                    },
                },
            },
        }
    </script>

    <!-- Page Styles -->
    <style>
        audio::-webkit-media-controls-panel {
            background-color: #f1f5f9; /* light mode */
        }
        .dark audio::-webkit-media-controls-panel {
            background-color: #334155; /* dark mode */
        }
        .loader {
            width: 24px;
            height: 24px;
            border: 3px solid;
            border-color: #1c5dff transparent;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 font-sans antialiased transition-colors duration-300">

    <div id="app-container" class="min-h-screen flex flex-col items-center p-4 md:p-8">

        <!-- Header -->
        <header class="w-full max-w-4xl flex justify-between items-center mb-8">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800 dark:text-white">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="inline-block -mt-1 mr-2 text-brand-primary-600">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10s10-4.48 10-10S17.52 2 12 2z"></path>
                    <path d="M6 12C6 9.79 7.79 8 10 8s4 1.79 4 4s-1.79 4-4 4"></path>
                    <path d="M10 12c0-1.1.9-2 2-2s2 .9 2 2s-.9 2-2 2"></path>
                    <path d="M14 12c0-1.1.9-2 2-2s2 .9 2 2s-.9 2-2 2"></path>
                </svg>
                Audio Denoiser Pro
            </h1>
            <button id="theme-toggle" class="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors">
                <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            </button>
        </header>

        <!-- Main Content Area -->
        <main class="w-full max-w-4xl bg-white dark:bg-gray-800 shadow-xl rounded-lg p-6 md:p-10">

            <!-- Recording Controls -->
            <section class="flex flex-col md:flex-row items-center justify-between gap-6 p-6 bg-gray-50 dark:bg-gray-700/50 rounded-lg border border-gray-200 dark:border-gray-700">
                <div class="flex items-center gap-4">
                    <div id="status-indicator" class="w-4 h-4 rounded-full bg-gray-400 dark:bg-gray-500 transition-all"></div>
                    <span id="status-text" class="text-lg font-medium text-gray-600 dark:text-gray-300">Ready to record</span>
                </div>
                <button id="record-button" class="w-full md:w-auto flex items-center justify-center gap-3 px-8 py-4 bg-brand-primary-600 text-white font-semibold rounded-lg shadow-lg hover:bg-brand-primary-700 focus:outline-none focus:ring-4 focus:ring-brand-primary-300 dark:focus:ring-brand-primary-800 transition-all duration-300 transform hover:scale-105">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>
                    Start Recording
                </button>
            </section>

            <!-- Recordings List -->
            <section id="recordings-section" class="mt-10">
                <h2 class="text-xl font-semibold text-gray-700 dark:text-gray-200 mb-4 pb-2 border-b border-gray-200 dark:border-gray-700">
                    Your Recordings
                </h2>
                <div id="recordings-list" class="flex flex-col gap-6">
                    <!-- Empty state -->
                    <div id="empty-state" class="text-center text-gray-500 dark:text-gray-400 py-10">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-4 text-gray-400"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>
                        Your recorded audio clips will appear here.
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Template for recording items -->
    <template id="recording-item-template">
        <div class="recording-item p-5 bg-gray-50 dark:bg-gray-800/60 rounded-lg border border-gray-200 dark:border-gray-700 shadow-sm">
            <div class="flex flex-col md:flex-row md:items-center justify-between gap-4">
                <h3 class="text-lg font-semibold text-brand-primary-700 dark:text-brand-primary-300 file-name">sample.wav</h3>
                <span class="text-sm text-gray-500 dark:text-gray-400 file-info">(Size: 1.2 MB | Duration: 0:15)</span>
            </div>
            
            <div class="mt-4 grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Original Audio -->
                <div class="original-audio-container">
                    <label class="block text-sm font-medium text-gray-600 dark:text-gray-300 mb-2">Original Audio</label>
                    <audio controls class="w-full original-audio rounded-lg" src=""></audio>
                </div>

                <!-- Processed Audio / Denoise Button -->
                <div class="processed-container">
                    <button class="denoise-button w-full h-full min-h-[54px] px-6 py-3 bg-white dark:bg-gray-700 border-2 border-brand-primary-500 text-brand-primary-600 dark:text-brand-primary-300 dark:border-brand-primary-400 font-semibold rounded-lg shadow-sm hover:bg-brand-primary-50 dark:hover:bg-gray-600 transition-all flex items-center justify-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="magic-icon"><path d="M22 11.08V12c0 1.66-1.34 3-3 3s-3-1.34-3-3V(1.08" /><path d="M11.66 6c-2.49 0-4.5 2.01-4.5 4.5V12c0 1.66-1.34 3-3 3s-3-1.34-3-3V(1.08" /><path d="M7 19c-2.21 0-4-1.79-4-4V12"/><path d="M17 19c2.21 0 4-1.79 4-4V12"/><path d="M12 2v2.34"/><path d="M9 3.66L10.06 5"/><path d="M15 3.66L13.94 5"/></svg>
                        Remove Noise
                    </button>
                    <div class="processed-audio-wrapper hidden">
                        <label class="block text-sm font-medium text-gray-600 dark:text-gray-300 processing-status mb-2">Processed Output</label>
                        <div class="processing-loader flex items-center gap-3 h-[54px]">
                            <span class="loader"></span>
                            <span class="text-gray-500 dark:text-gray-400">Uploading & processing...</span>
                        </div>
                        <audio controls class="processed-audio w-full rounded-lg hidden" src=""></audio>
                    </div>
                </div>
            </div>
            <div class="error-message text-red-500 dark:text-red-400 text-sm mt-4 hidden"></div>
        </div>
    </template>


    <!-- APP LOGIC JAVASCRIPT -->
    <script type="module">
        // --- App State ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordingCount = 0;
        let recordingStartTime;

        // --- DOM Elements ---
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const themeIconLight = document.getElementById('theme-icon-light');
        const recordButton = document.getElementById('record-button');
        const statusIndicator = document.getElementById('status-indicator');
        const statusText = document.getElementById('status-text');
        const recordingsList = document.getElementById('recordings-list');
        const emptyState = document.getElementById('empty-state');
        const recordingTemplate = document.getElementById('recording-item-template');

        // --- Core Functions ---

        function init() {
            themeToggle.addEventListener('click', toggleTheme);
            checkInitialTheme();
            recordButton.addEventListener('click', handleRecordButtonClick);
            checkMicPermission();
        }

        async function checkMicPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                console.log("Mic permission granted.");
            } catch (err) {
                console.error("Mic permission denied:", err);
                statusText.textContent = "Mic permission denied.";
                statusIndicator.classList.add('bg-red-500');
                recordButton.disabled = true;
                recordButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }

        function handleRecordButtonClick() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isRecording = true;
                audioChunks = [];
                
                // --- MODIFICATION: Try to record in WAV if possible ---
                // Browsers default to 'audio/webm', which requires FFmpeg on the server to decode.
                // 'audio/wav' is uncompressed but is read by librosa/soundfile without FFmpeg.
                let mimeType = 'audio/webm'; // Default
                
                if (MediaRecorder.isTypeSupported('audio/wav;codecs=pcm')) {
                    mimeType = 'audio/wav;codecs=pcm';
                } else if (MediaRecorder.isTypeSupported('audio/wav')) {
                    mimeType = 'audio/wav';
                }
                console.log("Using MIME type:", mimeType);
                // --- END MODIFICATION ---

                const options = { mimeType: mimeType }; 
                mediaRecorder = new MediaRecorder(stream, options);

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    stream.getTracks().forEach(track => track.stop());
                    const duration = (new Date() - recordingStartTime) / 1000;
                    
                    // The browser records as 'audio/webm' (or 'audio/wav' if supported)
                    const audioBlob = new Blob(audioChunks, { type: mimeType }); // Use the determined mimeType
                    
                    recordingCount++;
                    // We name it .wav as requested.
                    const fileName = `sample${recordingCount}.wav`;
                    const audioFile = new File([audioBlob], fileName, { type: audioBlob.type });

                    addRecordingToUI(audioFile, duration);
                };

                recordingStartTime = new Date();
                recordButton.textContent = "Stop Recording";
                recordButton.classList.add('bg-red-600', 'hover:bg-red-700', 'animate-pulse');
                recordButton.classList.remove('bg-brand-primary-600', 'hover:bg-brand-primary-700');
                statusText.textContent = "Recording...";
                statusIndicator.classList.add('bg-red-500', 'animate-pulse');
                statusIndicator.classList.remove('bg-gray-400', 'dark:bg-gray-500');

                mediaRecorder.start();

            } catch (err) {
                console.error("Error starting recording:", err);
                statusText.textContent = "Failed to start recording.";
                statusIndicator.classList.add('bg-red-500');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            }
            isRecording = false;

            recordButton.textContent = "Start Recording";
            recordButton.classList.remove('bg-red-600', 'hover:bg-red-700', 'animate-pulse');
            recordButton.classList.add('bg-brand-primary-600', 'hover:bg-brand-primary-700');
            statusText.textContent = "Ready to record";
            statusIndicator.classList.remove('bg-red-500', 'animate-pulse');
            statusIndicator.classList.add('bg-gray-400', 'dark:bg-gray-500');
        }

        function addRecordingToUI(audioFile, duration) {
            if (emptyState) {
                emptyState.classList.add('hidden');
            }

            const audioUrl = URL.createObjectURL(audioFile);
            const fileSize = (audioFile.size / (1024 * 1024)).toFixed(2);
            const durationStr = new Date(duration * 1000).toISOString().substr(14, 5);

            const newItem = recordingTemplate.content.cloneNode(true);
            
            newItem.querySelector('.file-name').textContent = audioFile.name;
            newItem.querySelector('.file-info').textContent = `(Size: ${fileSize} MB | Duration: ${durationStr})`;
            newItem.querySelector('.original-audio').src = audioUrl;

            const denoiseButton = newItem.querySelector('.denoise-button');
            const recordingItem = newItem.querySelector('.recording-item');
            
            denoiseButton.addEventListener('click', () => {
                uploadAndDenoise(audioFile, recordingItem);
            });

            recordingsList.appendChild(newItem);
        }

        /**
         * Uploads the audio file to the Flask server and shows the result.
         * @param {File} audioFile - The audio file to process.
         * @param {HTMLElement} itemElement - The .recording-item element in the DOM.
         */
        async function uploadAndDenoise(audioFile, itemElement) {
            const denoiseButton = itemElement.querySelector('.denoise-button');
            const processedWrapper = itemElement.querySelector('.processed-audio-wrapper');
            const loader = itemElement.querySelector('.processing-loader');
            const statusLabel = itemElement.querySelector('.processing-status');
            const processedAudio = itemElement.querySelector('.processed-audio');
            const errorMessage = itemElement.querySelector('.error-message');

            // 1. Update UI to "processing" state
            denoiseButton.classList.add('hidden');
            processedWrapper.classList.remove('hidden');
            loader.classList.remove('hidden');
            processedAudio.classList.add('hidden');
            errorMessage.classList.add('hidden');
            statusLabel.textContent = "Uploading & processing...";

            try {
                // 2. Prepare data and send to server
                const formData = new FormData();
                formData.append('file', audioFile, audioFile.name);

                // This 'fetch' sends the file to the '/denoise' route in your app.py
                const response = await fetch('/denoise', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    // Try to get error message from server's JSON response
                    let errorMsg = `Server error: ${response.status}`;
                    try {
                        const errorJson = await response.json();
                        errorMsg = errorJson.error || errorMsg;
                    } catch (e) { /* ignore if response wasn't json */ }
                    throw new Error(errorMsg);
                }

                // 3. Get cleaned audio back as a Blob
                const cleanedAudioBlob = await response.blob();
                const denoisedUrl = URL.createObjectURL(cleanedAudioBlob);

                // 4. Update UI with result
                loader.classList.add('hidden');
                statusLabel.textContent = "Processed Output";
                processedAudio.src = denoisedUrl;
                processedAudio.type = "audio/wav";
                processedAudio.classList.remove('hidden');

            } catch (e) {
                console.error("Error during denoising:", e);
                loader.classList.add('hidden');
                statusLabel.textContent = "Error during processing";
                errorMessage.textContent = `Error: ${e.message}`;
                errorMessage.classList.remove('hidden');
                denoiseButton.classList.remove('hidden'); // Show button to retry
                processedWrapper.classList.add('hidden');
            }
        }


        // --- Theme Toggling ---
        function toggleTheme() {
            if (document.documentElement.classList.contains('dark')) {
                document.documentElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                updateThemeIcons('light');
            } else {
                document.documentElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                updateThemeIcons('dark');
            }
        }

        function checkInitialTheme() {
            const preferredTheme = localStorage.getItem('theme');
            if (preferredTheme === 'light') {
                document.documentElement.classList.remove('dark');
                updateThemeIcons('light');
            } else {
                document.documentElement.classList.add('dark');
                updateThemeIcons('dark');
            }
        }

        function updateThemeIcons(theme) {
            if (theme === 'light') {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            } else {
                themeIconDark.classList.add('hidden');
                themeIconLight.classList.remove('hidden');
            }
        }

        // --- Start the app ---
        init();
    </script>

</body>
</html>


